Zunächst wurde die Entwicklung mit Phidata ausprobiert. Diese erwies sich jedoch im Nachhinein als nicht zuverlässig genug für unsere Anforderungen. 
Aus diesem Grund folgt im nächsten Abschnitt eine Implementierung mit Langchain.


\subsection{Phidata Implementation}
\label{sec:phidata-implementation}

Das folgende Python-Codebeispiel zeigt, wie die \texttt{Agent}-Klasse mit dem \texttt{SqlAgentStorage}-Backend kombiniert wird:

\begin{lstlisting}[language=Python, style=pythonstyle, caption={Phidata Implementation des KI-Agenten}]
from phi.agent import Agent
from phi.model.ollama import Ollama
from phi.storage.agent.sqlite import SqlAgentStorage

# Erstellen eines Speicherbackends mit einer Sqlite-Datenbank
storage = SqlAgentStorage(
    table_name="product_data (product_number INTEGER PRIMARY KEY, input_voltage INTEGER, input_current INTEGER, output_voltage INTEGER, output_current INTEGER, number_io_ports INTEGER, bus_protocol TEXT)",
    db_file="poc/db/data.db",
)

# Initialisieren des Agents mit dem Ollama-Modell und dem Speicher
agent = Agent(
    model=Ollama(id="deepseek-r1:14b"),
    markdown=True,
    storage=storage
)

# Ausgabe der Antwort im Terminal
agent.print_response("Which input voltage does the product with the product number 2 have? Take a look in your database first.")
\end{lstlisting}

\subsubsection{Ausgabe}

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=1\linewidth]{Figures/results/phidata_01.png} 
        \captionof{figure}{Beispielausgabe 1}
        \label{fig:phidata-bsp01}
    \end {center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=1\linewidth]{Figures/results/phidata_02.png} 
        \captionof{figure}{Beispielausgabe 2}
        \label{fig:phidata-bsp02}
    \end {center}
\end{figure}

\subsection{Erstellung der Datenbank}

Falls die Sqlite-Datenbank noch nicht existiert, muss sie erstellt werden. Der folgende Code stellt sicher, dass die Datenbank und die Tabelle existieren, und fügt einige Beispieldaten hinzu.

\begin{lstlisting}[language=Python, style=pythonstyle, caption={Code zur Erstellung der Beispiel-Datenbank}]
import sqlite3
import os

# Pfad zur Datenbankdatei
db_path = './poc/db/produkte.db'

# Überprüfen, ob die Datenbankdatei existiert
if not os.path.exists(db_path):
    # Erstellen der Datenbankdatei
    open(db_path, 'w').close()

    # Verbindung zur SQLite-Datenbank herstellen (wird erstellt, wenn sie nicht existiert)
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Tabelle erstellen
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS produkte (
        product_number INTEGER PRIMARY KEY,
        input_voltage INTEGER,
        input_current INTEGER,
        output_voltage INTEGER,
        output_current INTEGER,
        number_io_ports INTEGER,
        bus_protocol TEXT
    )
    ''')

    # Beispiel-Daten hinzufügen
    cursor.execute('''
    INSERT INTO produkte (product_number, input_voltage, input_current, output_voltage, output_current, number_io_ports, bus_protocol)
    VALUES
    (1, 24, 2, 24, 2, 4, 'Modbus TCP'),
    (2, 12, 1, 24, 2, 2, 'Modbus RTU'),
    (3, 24, 2, 12, 1, 4, 'Modbus TCP')
    ''')

    # Änderungen speichern und Verbindung schließen
    conn.commit()
    conn.close()
else:
    print("Datenbank existiert bereits.")
\end{lstlisting}

Dieser Code stellt sicher, dass die Datenbankdatei existiert, und erstellt gegebenenfalls eine neue Datenbank mit einer Tabelle für Produktdaten. Es werden Beispieldaten in die Tabelle eingefügt, wenn die Datenbank neu erstellt wird.

\subsection{Offizielle Dokumentation}

\subsubsection{Sqlite Agent Storage}

Phidata unterstützt die Verwendung von Sqlite als Speicher-Backend für Agents über die \texttt{SqlAgentStorage}-Klasse. \cite{phidata_sqliteagent}

\textbf{Verwendung:}

Es ist erforderlich, entweder \texttt{db\_url}, \texttt{db\_file} oder \texttt{db\_engine} anzugeben. Das folgende Beispiel verwendet \texttt{db\_file}:

\begin{lstlisting}[language=Python, style=pythonstyle, caption={Verwendung von \texttt{SqlAgentStorage}}]
from phi.storage.agent.sqlite import SqlAgentStorage

# Erstellen eines Speicherbackends mit einer Sqlite-Datenbank
storage = SqlAgentStorage(
    table_name="agent_sessions",     # Speichert Sitzungen in der ai.sessions-Tabelle
    db_file="tmp/data.db",           # Sqlite-Datenbankdatei
)

# Speicher zum Agent hinzufügen
agent = Agent(storage=storage)
\end{lstlisting}

\subsubsection{Parameter}

Der Konstruktor von \texttt{SqlAgentStorage} nimmt die folgenden Parameter entgegen:

\begin{table}[h]
    \caption{Parameter des \texttt{SqlAgentStorage}-Konstruktors}
    \centering
    \begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|p{6cm}|}
        \hline
        \textbf{Parameter}        & \textbf{Typ}      & \textbf{Standardwert} & \textbf{Beschreibung}                                        \\
        \hline
        \texttt{table\_name}      & string             & -                & Name der zu verwendenden Tabelle.                              \\
        \texttt{schema}           & Optional string    & "ai"             & Name des Schemas, Standardwert ist "ai".                        \\
        \texttt{db\_url}          & Optional string    & None             & Datenbank-URL, falls angegeben.                                \\
        \texttt{db\_engine}       & Optional \texttt{Engine} & None         & Zu verwendender Datenbank-Engine.                              \\
        \texttt{schema\_version}  & integer            & 1                & Version des Schemas, Standardwert ist 1.                        \\
        \texttt{auto\_}\texttt{upgrade\_} \texttt{schema} & boolean        & False            & Wenn wahr, wird das Schema automatisch aktualisiert, wenn erforderlich. \\
        \hline
    \end{tabular}
\end{table}

\subsection{Langchain Implementation}
\label{sec:langchain-implementation}

Das folgende Python-Codebeispiel zeigt, wie ein KI-Agent mit Langchain implementiert wird, um eine SQLite-Datenbank zu durchsuchen und mit einem LLM-Modell zu interagieren:

\begin{lstlisting}[style=pythonstyle, caption={Langchain Implementation des KI-Agenten}]
import sqlite3
from langchain.chat_models import ChatOllama
from langchain.agents import initialize_agent, AgentType
from langchain.tools import Tool
from langchain.memory import ConversationBufferMemory
from langchain.tools.sql_database.tool import QuerySQLDataBaseTool
from langchain.sql_database import SQLDatabase

# SQLite-Datenbank laden
db_path = "./poc/db/produkte.db"  # Anpassen an den tatsächlichen Speicherort
database = SQLDatabase.from_uri(f"sqlite:///{db_path}")

# Abfrage-Tool für den Agenten definieren
query_tool = QuerySQLDataBaseTool(db=database)

# Ollama LLM initialisieren
llm = ChatOllama(model="llama3.1:latest")  # Modell ggf. anpassen

# Konversationsspeicher für Kontext
memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

# Werkzeuge für den Agenten definieren
tools = [
    Tool(
        name="QuerySQLiteDB",
        func=query_tool.run,
        description="Verwende dieses Tool, um Informationen aus der SQLite-Datenbank abzurufen. Eingabe sollte eine natürliche Sprachabfrage sein, die automatisch in eine SQL-Abfrage umgewandelt wird. Tabelle 'produkte': (product_number INTEGER PRIMARY KEY, input_voltage INTEGER, input_current INTEGER, output_voltage INTEGER, output_current INTEGER, number_io_ports INTEGER, bus_protocol TEXT)"
    )
]

# LangChain-Agent initialisieren
agent = initialize_agent(
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    tools=tools,
    llm=llm,
    verbose=True,
    memory=memory
)

# Chat-Schleife starten
print("Chat mit dem LLM (tippe 'exit' zum Beenden)")
while True:
    user_input = input("You: ")
    if user_input.lower() == "exit":
        break
    response = agent.run(user_input)
    print("LLM:", response)

# Datenbankverbindung schließen
conn.close()
\end{lstlisting}

\subsubsection{Funktionsweise}
Der Agent nutzt das \texttt{QuerySQLiteDB}-Tool, um bei Bedarf eigenständig SQL-Abfragen zu generieren. Das Ollama LLM verarbeitet die Benutzereingaben und entscheidet, ob eine Datenbankabfrage erforderlich ist. Durch den Konversationsspeicher bleibt der Kontext über mehrere Interaktionen hinweg erhalten.

\subsubsection{Beispielabfragen}
\begin{itemize}
    \item \texttt{Which input voltage does the product with product number 2 have?}
    \item \texttt{How many IO ports does product 1 have?}
\end{itemize}

Diese Implementierung bietet eine zuverlässige Alternative zur Phidata-Lösung und ermöglicht eine flexible Interaktion mit der SQLite-Datenbank.
